package se.andreas;

import java.util.ArrayList;
import java.util.List;

public class Parser {
    // List of tokens generated by the lexer
    public final ArrayList<Lexer.Token> tokens;
    // Current position in the token list
    private int current = 0;

    // Constructor to initialize the parser with tokens
    public Parser(ArrayList<Lexer.Token> tokens) {
        this.tokens = tokens;
    }

    // Check if there are more tokens to read
    private boolean canPeek() {
        return current < tokens.size();
    }

    // Get the current token without consuming it
    private Lexer.Token peek() {
        if (canPeek()) {
            return tokens.get(current);
        }
        throw new RuntimeException("Unexpected end of input");
    }

    // Move to the next token and return the current token
    private Lexer.Token advance() {
        if (canPeek()) {
            return tokens.get(current++);
        }
        throw new RuntimeException("Unexpected end of input");
    }

    // Check if the current token matches the expected type and consume it
    private boolean match(Lexer.Type type) {
        if (canPeek() && peek().type == type) {
            advance();
            return true;
        }
        return false;
    }

    // Consume the current token if it matches the expected type
    private Lexer.Token consume(Lexer.Type type) {
//        System.out.println("About to consume: " + peek());
        if (match(type)) {
//            System.out.println("Returning: " + tokens.get(current-1));
            return tokens.get(current-1);
        }
        throw new RuntimeException("Expected token: " + type);
    }

    // Entry point for parsing the tokens into an AST
    public ASTNode parse() {
        try {
            // Start parsing from the expression level
            return expression();
        } catch (RuntimeException e) {
            // Log any parsing errors
            System.err.println("Parse error: " + e.getMessage());
            return null;
        }
    }

    // Parse an expression, which is a sequence of terms separated by 'or' (|)
    private ASTNode expression() {
        // Parse the first term
        ASTNode node = term();
        // While there are 'or' tokens, parse additional terms
        while (match(Lexer.Type.Or)) {
            ASTNode right = term();
            // Create an OrNode to represent the 'or' operation
            node = new OrNode(node, right);
        }
        return node;
    }

    // Parse a term, which is a sequence of factors
    private ASTNode term() {
        // Parse the first factor
        ASTNode node = factor();
        // While there are more factors (characters, any, or groups), parse them
        while (canPeek() && (peek().type == Lexer.Type.Char || peek().type == Lexer.Type.Any || peek().type == Lexer.Type.LParen)) {
            ASTNode nextFactor = factor();
            // Create a ConcatNode to represent concatenation
            node = new ConcatNode(node, nextFactor);
        }
        return node;
    }

    // Parse a factor, which can be a character, any character, group, etc.
    private ASTNode factor() {
        // Check if there are more tokens to read
        if (!canPeek()) {
            throw new RuntimeException("Unexpected end of input");
        }
        // Get the current token
        Lexer.Token token = peek();
        // Determine the type of factor based on the token type
        switch (token.type) {
            case Char:
                // Consume the character token and create a CharNode
                consume(Lexer.Type.Char);
                return new CharNode(token.content.charAt(0));
            case Any:
                // Consume the any token and create an AnyNode
                consume(Lexer.Type.Any);
                return new AnyNode();
            case LParen:
                // Consume the left parenthesis and parse the expression inside the group
                consume(Lexer.Type.LParen);
                ASTNode expr = expression();
                consume(Lexer.Type.RParen);
                return new GroupNode(expr);
            case Star:
                // Parse the operand and consume the star token
                ASTNode operand = factor();
                consume(Lexer.Type.Star);
                return new StarNode(operand);
            case LBrace:
                // Consume the left brace, parse the count, and consume the right brace
                consume(Lexer.Type.LBrace);
                Lexer.Token numberToken = consume(Lexer.Type.Number);
                consume(Lexer.Type.RBrace);
                int count = Integer.parseInt(numberToken.content);
                return new CountNode(factor(), count);
            case BackslashI:
                // Consume the case-insensitive token and create a CaseInsensitiveNode
                consume(Lexer.Type.BackslashI);
                return new CaseInsensitiveNode(factor());
            case BackslashO:
                // Consume the capture group token and parse the capture group number
                consume(Lexer.Type.BackslashO);
                consume(Lexer.Type.LBrace);
                Lexer.Token captureGroupToken = consume(Lexer.Type.Number);
                consume(Lexer.Type.RBrace);
                int captureGroup = Integer.parseInt(captureGroupToken.content);
                return new CaptureNode(factor(), captureGroup);
            default:
                // Throw an error for unexpected tokens
                throw new RuntimeException("Unexpected token: " + token);
        }
    }


    // Abstract base class for AST nodes
    abstract static class ASTNode {
        // List of child nodes (operands)
        protected List<ASTNode> operands = new ArrayList<>();

        // Abstract method to evaluate the node
        public abstract String evaluate(String input);

        // Add a child node
        public void addOperand(ASTNode node) {
            operands.add(node);
        }

        // Get the list of child nodes
        public List<ASTNode> getOperands() {
            return operands;
        }

        // Override toString() to provide a detailed representation of the parse tree
        @Override
        public String toString() {
            return toStringHelper(0); // Start with indentation level 0
        }

        // Helper method to handle indentation
        private String toStringHelper(int indentLevel) {
            StringBuilder stringBuilder = new StringBuilder();
            // Add indentation
            for (int i = 0; i < indentLevel; i++) {
                stringBuilder.append("  ");
            }
            // Add node type
            stringBuilder.append(this.getClass().getSimpleName());
            // Add node-specific details
            stringBuilder.append(getNodeDetails());
            stringBuilder.append(" [\n");
            // Add child nodes with increased indentation
            for (ASTNode operand : operands) {
                stringBuilder.append(operand.toStringHelper(indentLevel + 1)).append("\n");
            }
            // Close the node
            for (int i = 0; i < indentLevel; i++) {
                stringBuilder.append("  ");
            }
            stringBuilder.append("]");
            return stringBuilder.toString();
        }

        // Method to provide node-specific details (override in subclasses)
        protected String getNodeDetails() {
            return "";
        }
    }

    // Node representing a single character
    class CharNode extends ASTNode {
        public final char value;

        public CharNode(char value) {
            this.value = value;
        }

        @Override
        public String evaluate(String input) {
            // Evaluate a single character
            if (!input.isEmpty() && input.indexOf(value) != -1) {
                return String.valueOf(value);
            }
            return "";
        }

        @Override
        protected String getNodeDetails() {
            return " ('" + value + "')";
        }
    }

    // Node representing any character
    class AnyNode extends ASTNode {
        @Override
        public String evaluate(String input) {
            // Evaluate any character
            if (!input.isEmpty()) {
                return String.valueOf(input.charAt(0));
            }
            return "";
        }

        @Override
        protected String getNodeDetails() {
            return " (.)";
        }
    }

    // Node representing an 'or' operation
    class OrNode extends ASTNode {
        public OrNode(ASTNode left, ASTNode right) {
            addOperand(left);
            addOperand(right);
        }

        @Override
        public String evaluate(String input) {
            // Evaluate the left and right operands
            String leftResult = operands.get(0).evaluate(input);
            String rightResult = operands.get(1).evaluate(input);
            // Return success if either operand succeeds
            if (!leftResult.isEmpty()) {
                return leftResult;
            } else if (!rightResult.isEmpty()) {
                return rightResult;
            }
            return "";
        }

        @Override
        protected String getNodeDetails() {
            return " (+)";
        }
    }

    // Node representing concatenation
    class ConcatNode extends ASTNode {
        public ConcatNode(ASTNode left, ASTNode right) {
            addOperand(left);
            addOperand(right);
        }

        @Override
        public String evaluate(String input) {
            // Evaluate the left and right operands
            String leftResult = operands.get(0).evaluate(input);
            String rightResult = operands.get(1).evaluate(input);
            // Return the concatenation of both results
            return leftResult + rightResult;
        }

        @Override
        protected String getNodeDetails() {
            return " (concat)";
        }
    }

    // Node representing a group (expression in parentheses)
    class GroupNode extends ASTNode {
        public GroupNode(ASTNode expr) {
            addOperand(expr);
        }

        @Override
        public String evaluate(String input) {
            // Evaluate the expression inside the group
            return operands.get(0).evaluate(input);
        }

        @Override
        protected String getNodeDetails() {
            return " (group)";
        }
    }

    // Node representing zero or more occurrences
    class StarNode extends ASTNode {
        public StarNode(ASTNode operand) {
            addOperand(operand);
        }

        @Override
        public String evaluate(String input) {
            // Evaluate the operand zero or more times
            StringBuilder result = new StringBuilder();
            String operandResult = operands.get(0).evaluate(input);
            while (!operandResult.isEmpty()) {
                result.append(operandResult);
                operandResult = operands.get(0).evaluate(input);
            }
            return result.toString();
        }

        @Override
        protected String getNodeDetails() {
            return " (*)";
        }
    }

    // Node representing a specific number of occurrences
    class CountNode extends ASTNode {
        private final int count;

        public CountNode(ASTNode operand, int count) {
            addOperand(operand);
            this.count = count;
        }

        @Override
        public String evaluate(String input) {
            // Evaluate the operand a specific number of times
            StringBuilder result = new StringBuilder();
            for (int i = 0; i < count; i++) {
                String operandResult = operands.get(0).evaluate(input);
                if (operandResult.isEmpty()) {
                    return "";
                }
                result.append(operandResult);
            }
            return result.toString();
        }

        @Override
        protected String getNodeDetails() {
            return " (count=" + count + ")";
        }
    }

    // Node representing case-insensitive matching
    class CaseInsensitiveNode extends ASTNode {
        public CaseInsensitiveNode(ASTNode operand) {
            addOperand(operand);
        }

        @Override
        public String evaluate(String input) {
            // Evaluate the operand and convert the result to lowercase
            String operandResult = operands.get(0).evaluate(input);
            if (operandResult.isEmpty()) {
                return "";
            }
            return operandResult.toLowerCase();
        }

        @Override
        protected String getNodeDetails() {
            return " (case-insensitive)";
        }
    }

    // Node representing a capture group
    class CaptureNode extends ASTNode {
        private final int captureGroup;

        public CaptureNode(ASTNode operand, int captureGroup) {
            addOperand(operand);
            this.captureGroup = captureGroup;
        }

        @Override
        public String evaluate(String input) {
            // Evaluate the operand and handle capture group logic
            String operandResult = operands.get(0).evaluate(input);
            if (operandResult.isEmpty()) {
                return "";
            }
            // Implement capture group logic here
            return operandResult;
        }

        @Override
        protected String getNodeDetails() {
            return " (capture=" + captureGroup + ")";
        }
    }
}
